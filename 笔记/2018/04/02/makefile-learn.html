<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>Makefile初探-1</title>
	<meta name="description" content="makefile的基本概念">
	<meta name="keywords" content="makefile, 寒鸥惊起一双双" />
	<link rel="canonical" href="https://blog.bobliao.xyz/%E7%AC%94%E8%AE%B0/2018/04/02/makefile-learn.html">
	<link rel="alternate" type="application/rss+xml" title="寒鸥惊起一双双" href="https://blog.bobliao.xyz/feed.xml" />
   	<link rel="stylesheet" type="text/css" href="/css/index.css">
</head>

<body>
<div class="body-wrapper">
<div class="nav-header">
<a href="/">寒鸥惊起一双双</a> | <a href="https://github.com/foreverlms" target="_blank">Github</a> |<a href="/about"> 关于我 </a></div>
<div class="main-body">
<header>
<h2>Makefile初探-1</h2>
<p><i>2018-04-02</i></p>
</header>
<article>
<p>makefile的基本概念
<!--more--></p>

<p>makefile是在编译中大型程序中使用的自动化编译工具 <code class="highlighter-rouge">make</code> 依赖的指令文件。这样可以使得程序的编译更加便捷快速。
makefile的一般规则如下：</p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">target ... </span><span class="o">:</span> <span class="nf">prerequisites ...</span>
<span class="err">command</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">target</code>即是一个目标文件，它可以是可执行程序、目标中间文件、标记（label）等。这个目标要想编译出来需要的前提条件就是<code class="highlighter-rouge">prerequisites</code>这些已存在的文件。编译过程中的规则则是由<code class="highlighter-rouge">command</code>里面的各个命令组成。<code class="highlighter-rouge">command</code>以一个<code class="highlighter-rouge">Tab</code>起头。<code class="highlighter-rouge">make</code>会比较目标文件与条件中的文件更新时间，一旦有文件被修改，<code class="highlighter-rouge">make</code>就会依赖于这些前提文件进行重新编译。<code class="highlighter-rouge">makefile</code>中第一个<code class="highlighter-rouge">target</code>会被认为是<code class="highlighter-rouge">make</code>的默认目标。
当<code class="highlighter-rouge">prerequisites</code>是空的时候，前面的目标文件被当成一个命令，使用<code class="highlighter-rouge">make</code>执行时会直接执行<code class="highlighter-rouge">command</code>里的命令。</p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">clean </span><span class="o">:</span>
	<span class="nb">rm </span>edit main.o kbd.o command.o display.o <span class="se">\</span>
	insert.o search.o files.o utils.o
</code></pre></div></div>
<p>执行这个<code class="highlighter-rouge">make clean</code>会将当前文件夹下的几个中间文件删除掉。
<code class="highlighter-rouge">makefile</code>中可以使用变量，类似于C语言中的宏：</p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">edit </span><span class="o">:</span> <span class="nf">main.o kda.o command.o</span>
	gcc <span class="nt">-o</span> edit main.o kda.o command.o
</code></pre></div></div>
<p>这里面如果要向<code class="highlighter-rouge">edit</code>的依赖项中添加文件，那么也得向<code class="highlighter-rouge">command</code>中加入同样的文件，<code class="highlighter-rouge">makefile</code>一大，就很难批量处理，这时候可以声明变量：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>objects = main.o kda.o command.o
</code></pre></div></div>
<p>那么上面的makefile可以改成：</p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">objects</span> <span class="o">=</span> main.o kda.o command.o

<span class="nl">edit </span><span class="o">:</span> <span class="nf">$(objects)</span>
	gcc <span class="nt">-o</span> edit <span class="nv">$(objects)</span>
</code></pre></div></div>
<p>通过美元符号<code class="highlighter-rouge">$(变量名)</code>的方式来引用变量。
<code class="highlighter-rouge">make</code>工具会<code class="highlighter-rouge">.o</code>文件对应的<code class="highlighter-rouge">.c</code>文件自动的添加到依赖关系中。如果找到一个<code class="highlighter-rouge">foo.o</code>，那么对应的<code class="highlighter-rouge">foo.c</code>就会自动的加入到依赖关系并且会在<code class="highlighter-rouge">command</code>中自动隐式添加一行<code class="highlighter-rouge">gcc -o </code>。那么<code class="highlighter-rouge">foo,o</code>的生成就可以简写为：</p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">foo.o </span><span class="o">:</span> <span class="nf">other_files_list</span>
</code></pre></div></div>
<p>其中的<code class="highlighter-rouge">command</code>直接就不用写了。
<code class="highlighter-rouge">.PHONY</code>用来修饰<code class="highlighter-rouge">target</code>，表示它是一个“伪目标”。
总结：</p>
<ul>
  <li>显式规则</li>
  <li>隐式规则</li>
  <li>变量定义</li>
  <li>引用文件</li>
  <li>注释
makefile中只有行注释，注释以<code class="highlighter-rouge">#</code>开头。</li>
</ul>


</article>
<div id="info-bottom">
<hr>
<p>标签: <block class="tag"><a href="/archive/#makefile">makefile</a></block></p>
<p><b>留言</b>请用 <a href="https://github.com/foreverlms/foreverlms.github.io/issues"> Github Issues </a></p>
<p><b>聊天</b>请在 <a href="https://gitter.im/foreverlms/community" target="_blank">gitter.im/foreverlms</a> </p>
</div>

</div>
<div class="info-bottom"><div class="info-bottom-text">
License <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a> | Subscribe <a href="/feed.xml">RSS</a> | Email <a href="mailto:codechaser@163.com">codechaser囧163.com</a> | 博客模板 <a href="https://fzheng.me/" target="_blank">无求备斋笔记</a>
</div></div> 
</div>
</body>
<script src="https://use.typekit.net/hvv6ahj.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>
</html>