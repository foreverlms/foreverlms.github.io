<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>C Primer Plus--C预处理器和C库(1)</title>
	<meta name="description" content="C源码编译期间的预处理器(Preprocessor)">
	<meta name="keywords" content="c, C Primer Plus, 寒鸥惊起一双双" />
	<link rel="canonical" href="https://blog.bobliao.xyz/%E7%AC%94%E8%AE%B0/2018/04/08/c-preprocessor-1.html">
	<link rel="alternate" type="application/rss+xml" title="寒鸥惊起一双双" href="https://blog.bobliao.xyz/feed.xml" />
   	<link rel="stylesheet" type="text/css" href="/css/index.css">
</head>

<body>
<div class="body-wrapper">
<div class="nav-header">
<a href="/">寒鸥惊起一双双</a> | <a href="https://github.com/foreverlms" target="_blank">Github</a> |<a href="/about"> 关于我 </a></div>
<div class="main-body">
<header>
<h2>C Primer Plus--C预处理器和C库(1)</h2>
<p><i>2018-04-08</i></p>
</header>
<article>
<p>C源码编译期间的预处理器(Preprocessor)
<!--more--></p>

<center>&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=550472081&amp;auto=1&amp;height=66"&gt;&lt;/iframe&gt;</center>

<blockquote>
  <p>编译程序之前，先由预处理器检查程序（因此称为预处理器）。根据程序中使用的预处理器指令，预处理用符号缩略语所代表的内容替换程序中的缩略语。
预处理器可以根据你的请求包含其他文件，还可以让编译器处理哪些代码。预处理器不能理解C，它一般是接受一些文本并将其转换成其他文本。– (C Primer Plus中文第五版)</p>
</blockquote>

<center>
```mermaid
graph TD;
写好的C文件 --&gt; 编译器翻译,为预处理做准备
编译器翻译,为预处理做准备 --&gt; 预处理器寻找肯能存在的预处理指令,开始预处理
```
</center>

<h2 id="预处理符号">预处理符号</h2>
<h3 id="明显常量-define">明显常量 #define</h3>
<p><code class="highlighter-rouge">#define</code>定义的作用域从定义出现的位置开始直到文件的结尾。这里表明在函数里使用<code class="highlighter-rouge">#define</code>，凡是在它定义的后面的所有函数都是可以用的：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">void</span> <span class="nf">pp</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="cp">#define FF 10
</span>    <span class="n">pp</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pp</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"FF: %d "</span><span class="p">,</span><span class="n">FF</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>输出：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FF: 10
</code></pre></div></div>
<p>要时刻记住：<strong><code class="highlighter-rouge">#define</code>会把它之后的文件里的所有符合要求的文本替换掉。</strong>
每个<code class="highlighter-rouge">#define</code>行由三部分组成：</p>
<ul>
  <li>指令自身 <code class="highlighter-rouge">#define</code></li>
  <li>缩略语，即宏(macro)
宏的名字中不允许有空格，必须遵循C变量名规则</li>
  <li>替换列表或者主体(body)</li>
</ul>

<p>预处理器在程序中发现了宏的实例后，总会用实体代替该宏。从宏变成最终的替换文本的过程称为宏展开(macro expansion)。
宏可以分两种：</p>
<ul>
  <li>类对象宏 object-like macro
宏用来代表值</li>
  <li>类函数宏 function-like macro
外形和作用都与函数相似</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define TWO 2;
#define PX printf("X is: %d\n",x)
#define FMT "X+1 is: %d\n"
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span><span class="n">TWO</span><span class="p">;</span>
    <span class="n">PX</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="n">FMT</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>输出：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X is: 2
X+1 is: 3
</code></pre></div></div>
<p>上面的程序其实被预处理器改成了：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"X is: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"X+1 is: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">//先变成int y = TWO * TWO;</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"y is: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
</code></pre></div></div>
<p>注意，宏展开过程中，是进行替换，并不进行计算。<code class="highlighter-rouge">C编译器在编译时对所有常量表达式（只包含常量的表达式）求值，所以实际相乘过程发生在编译阶段，而不是预处理阶段。预处理器不进行计算，它只是按照指令进行文字替换操作。</code>
<strong>宏展开过程中，会用宏的等价（即<code class="highlighter-rouge">body</code>）来替换文本，如果宏的<code class="highlighter-rouge">body</code>本身还含有宏的话，会继续展开这些宏。但是，双引号中的与宏缩略语一样的字符串无法被替换。</strong></p>
<h4 id="重定义常量">重定义常量</h4>
<p>假设一个缩略语被定义后又在同文件中被定义，这样被称为重定义(redefinng a constant)。有的编译器会对这样提出警告，但允许重定义存在，有的则直接报错。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define SIX 3 * 3
#define SIX 3   *   3
</span><span class="c1">//上面这样的重定义会被编译器认为是重复定义，是相同的</span>

<span class="cp">#define SIX 3*3
</span><span class="c1">//这样的重定义与上面两种是不同的</span>
</code></pre></div></div>
<h4 id="在define中使用参数">在<code class="highlighter-rouge">#define</code>中使用参数</h4>

<p>类函数宏的定义中，用圆括号阔气一个或多个参数，随后这些参数出现在替换部分。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define SQUARE(X) X*X
</span><span class="c1">//一个参数X</span>

<span class="c1">//使用</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">SQUARE</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>
<p>宏调用和函数调用存在着区别：
程序运行时，函数调用把参数的值传递给函数，而编译前，宏调用把参数的语言符号传递给程序，仅仅是替换字符，而不计算。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define  SQUARE(X) X*X
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">SQUARE</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"SQUARE(x) is: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"SQUARE(x+2) is: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">SQUARE</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

</code></pre></div></div>
<p>输出：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SQUARE(x) is: 4
SQUARE(x+2) is: 8
</code></pre></div></div>
<p>按理说<code class="highlighter-rouge">square(2+2)</code>应该是16啊，怎么会是8呢？原来像刚才上面说的，预处理只是替换，因此<code class="highlighter-rouge">SQUARE(x+2)</code>中的<code class="highlighter-rouge">X</code>被<code class="highlighter-rouge">x+2</code>替换，最后成了<code class="highlighter-rouge">x+2*x+2</code>。<code class="highlighter-rouge">*</code>优先级高，，因此程序运行时先计算<code class="highlighter-rouge">2*x</code>，再加上<code class="highlighter-rouge">x</code>和<code class="highlighter-rouge">2</code>，也就成了<code class="highlighter-rouge">8</code>。要想实现平方的效果，需要重新定义：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define SQUARE(X) ((X)*(X))
</span></code></pre></div></div>
<p>即使这样定义，还是无法避免自增、自减情况下的错误:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">SQUARE</span><span class="p">(</span><span class="o">++</span><span class="n">x</span><span class="p">);</span>
</code></pre></div></div>
<p>这里替换成<code class="highlighter-rouge">++x</code>字符后，进行了两次增量运算，最后结果肯定不是平方了。因此，<strong>在宏中不要使用增量或减量运算符</strong>。<strong>而且一定要充分的使用圆括号来保证正确的运算顺序</strong>。</p>
<h5 id="在类函数宏中使用运算符">在类函数宏中使用<code class="highlighter-rouge">#</code>运算符</h5>
<p>上面说了在引号表示的字符串无法替换掉宏参数，，但是使用<code class="highlighter-rouge">#</code>预处理运算符，可以把传入的参量转化为文本替换到字符串里。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define SQUARE(X) (X)*(X)
</span>
<span class="cp">#define PF(X) printf("The square of " #X " is : %d\n",SQUARE(X))
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">PF</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">PF</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>输出：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The square of x is : 100
The square of 2+4 is : 36
</code></pre></div></div>
<h5 id="在宏中使用运算符">在宏中使用<code class="highlighter-rouge">##</code>运算符</h5>
<p><code class="highlighter-rouge">##</code>运算符把两个语言符号组合成单个语言符号：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define XVAR(X) x ## X
</span>
<span class="kt">int</span> <span class="n">XVAR</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span><span class="c1">//声明了一个标识符为x2的变量</span>
</code></pre></div></div>
<h5 id="可变宏和__va_args__">可变宏：<code class="highlighter-rouge">...</code>和<code class="highlighter-rouge">__VA_ARGS__</code></h5>
<p>宏定义中参数列表的最后一个参数为省略号，预定义宏<code class="highlighter-rouge">__VA_ARGS_</code>就可以被用在替换部分，以代表省略号省略了什么。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PF(X,...) printf("Result " #X " : " __VA_ARGS__)
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">PF</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">PF</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">"%d's power is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>输出：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Result 1 : 10
Result 2 : 4's power is 16
</code></pre></div></div>
<p>省略号只能代替最后的宏参数。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define WRONG(X, ... ,Y) #X #__VA_ARGS__ #Y)//错误
</span></code></pre></div></div>
<p>这里有个有趣的现象：一般想要打印字符串，字符串都得用双引号括起来，这里不用：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define STRING(... ) #__VA_ARGS__
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="n">STRING</span><span class="p">(</span><span class="n">abcdefg</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>输出：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>abcdefg
</code></pre></div></div>

</article>
<div id="info-bottom">
<hr>
<p>标签: <block class="tag"><a href="/archive/#c">c</a></block><block class="tag"><a href="/archive/#C Primer Plus">C Primer Plus</a></block></p>
<p><b>留言</b>请用 <a href="https://github.com/foreverlms/foreverlms.github.io/issues"> Github Issues </a></p>
<p><b>聊天</b>请在 <a href="https://gitter.im/foreverlms/community" target="_blank">gitter.im/foreverlms</a> </p>
</div>

</div>
<div class="info-bottom"><div class="info-bottom-text">
License <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a> | Subscribe <a href="/feed.xml">RSS</a> | Email <a href="mailto:codechaser@163.com">codechaser囧163.com</a> | 博客模板 <a href="https://fzheng.me/" target="_blank">无求备斋笔记</a>
</div></div> 
</div>
</body>
<script src="https://use.typekit.net/hvv6ahj.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>
</html>