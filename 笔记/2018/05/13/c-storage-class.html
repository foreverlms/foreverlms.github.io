<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>C存储类、链接和内存管理之存储类(storage class)</title>
	<meta name="description" content="C基本概念存储类(Storage Class)小记">
	<meta name="keywords" content="c, C Primer Plus, 寒鸥惊起一双双" />
	<link rel="canonical" href="https://blog.bobliao.xyz/%E7%AC%94%E8%AE%B0/2018/05/13/c-storage-class.html">
	<link rel="alternate" type="application/rss+xml" title="寒鸥惊起一双双" href="https://blog.bobliao.xyz/feed.xml" />
   	<link rel="stylesheet" type="text/css" href="/css/index.css">
</head>

<body>
<div class="body-wrapper">
<div class="nav-header">
<a href="/">寒鸥惊起一双双</a> | <a href="https://github.com/foreverlms" target="_blank">Github</a> |<a href="/about"> 关于我 </a></div>
<div class="main-body">
<header>
<h2>C存储类、链接和内存管理之存储类(storage class)</h2>
<p><i>2018-05-13</i></p>
</header>
<article>
<p>C基本概念存储类(Storage Class)小记</p>

<!--more-->

<h1 id="存储类">存储类</h1>

<p>C为变量提供了5种不同的存储类型：</p>
<ul>
  <li>自动</li>
  <li>寄存器</li>
  <li>具有代码块作用域的静态</li>
  <li>具有外部链接的静态</li>
  <li>具有内部链接的静态</li>
</ul>

<p>不同角度描述变量：</p>
<ul>
  <li><strong>存储时期</strong>  变量在内存中保留的时间</li>
  <li><strong>变量作用域(Scope)以及它的链接(Linkage)</strong> 变量的作用域和链接一起表明程序的哪些部分可以通过变量名来访问该变量</li>
</ul>

<p>不同的存储类提供了变量的作用域、链接以及存储时期的不同组合。</p>
<h2 id="作用域">作用域</h2>
<p>作用域分为：</p>
<ul>
  <li>代码块作用域(block scope)
代码块在C中指的是一对花括号之间。定义在代码块之间的变量其可见性仅存在于<strong>其定义处和闭花括号之间</strong>。函数的形式参量、for、while、if-else等中定义的变量都是属于代码块作用域。</li>
  <li>函数原型作用域(function prototype scope)
函数原型作用域<strong>从变量定义处一直到函数原型结尾</strong>，这解释了为什么我们平时定义函数原型的时候的形式参量名字可以与函数定义中形参名字不同，甚至根本没有名字：编译器只关心原型形参的数据类型，因为函数原型形参变量作用域极短，其名称并不重要。
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">function</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">);</span>
  <span class="kt">int</span> <span class="nf">function1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div>    </div>
    <p>但是有些情况下函数原型里的形参名称有作用：存在变长数组参量时。</p>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">function2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]);</span>
</code></pre></div>    </div>
    <p>变长数组<code class="highlighter-rouge">array</code>中使用的变量<code class="highlighter-rouge">m n</code>是之前已经声明的。</p>
  </li>
  <li>文件作用域(file scope)
一个在所有函数之外定义的变量具有文件作用域。具有文件作用域的变量其可见性存在于<strong>其定义处到文件结尾处</strong>。这样的变量也被成为<strong>全局变量(global variable)</strong>。
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">function</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">file_scope</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="nf">function</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
	
  <span class="p">}</span>
</code></pre></div>    </div>
    <p>这里面<code class="highlighter-rouge">file_scope</code>对于<code class="highlighter-rouge">main</code>和<code class="highlighter-rouge">function</code>两个函数都是可见的。</p>
  </li>
</ul>

<h2 id="链接">链接</h2>
<p>C变量具有下列三种链接之一：</p>
<ul>
  <li>外部链接 external linkage</li>
  <li>内部链接 internal linkage</li>
  <li>空链接 no linkage</li>
</ul>

<p>具有函数原型作用域或者代码块作用域的变量具有空链接，他们是由其定义所在的代码块或者函数原型私有的。具有文件作用域的变量可能有内部或者外部链接。有外部链接的变量可以在一个多文件程序任何地方进行访问。一个具有内部链接的变量可以在其所在的单个文件里任何地方访问。
区分一个具有文件作用域是外部链接还是内部链接可以看<code class="highlighter-rouge">static</code>关键字。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">full_global</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//内部链接 只在本文件中全局可见</span>
<span class="kt">int</span> <span class="n">file_global</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//外部链接 full_global可以被同一程序多个文件访问</span>
</code></pre></div></div>
<h2 id="存储时期">存储时期</h2>
<p>C变量可以有以下两种存储时期之一：</p>
<ul>
  <li>静态存储时期 static storage duration
具有静态存储时期的变量会在程序执行期间一直存在。具有文件作用域的变量是具有静态存储时期的。</li>
  <li>自动存储时期 automatic storage duration
具有代码块作用域的变量<strong>一般</strong>情况下具有自动存储时期。这样的变量在程序进入代码块时被分配内存，退出代码快时其内存被释放。</li>
</ul>

<p>由以上作用域、链接、存储时期得到了五种存储类：
存储类 |  存储时期 | 作用域 | 链接 | 声明方式
—-|—–|—-|—-|—-|
自动 | 自动 | 代码块 | 空| 代码块内
寄存器 | 自动 | 代码块 | 空 | 代码块内，使用关键字<code class="highlighter-rouge">register</code>
具有外部链接的静态 | 静态|文件|外部|所有函数之外
具有内部链接的静态|静态|文件|内部|所有函数之外，使用修饰符<code class="highlighter-rouge">static</code>
空链接的静态|静态|代码块|空|代码块内，使用修饰符<code class="highlighter-rouge">static</code></p>

<h2 id="自动变量">自动变量</h2>
<p>默认情况下，在代码块或函数的头部定义的任意变量都属于自动存储类型。也可以使用关键字<code class="highlighter-rouge">auto</code>来显示的表明此变量为自动变量：<code class="highlighter-rouge">auto int auto_var = 0;</code>，这样做的目的可以是显式覆盖一个外部函数定义的同名变量或者强调该变量的存储类型不可以改变为其他存储方式。<code class="highlighter-rouge">auto</code>称为存储类说明符(storage class specifier)。
自动变量具有代码块作用域和空链接，这样只有在变量定义的代码块里才可以通过变量名访问该变量。C也允许通过向函数传递参数地址来访问变量，但这样属于间接访问，不是通过变量名直接访问的。
覆盖（hide）指的是不同作用域的变量名称相同的情况下，会根据程序所在环境按名称访问相应的变量值。举个栗子：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">){</span>
     <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
     <span class="n">x</span><span class="o">++</span><span class="p">;</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
 <span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
</code></pre></div></div>
<p>输出：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11
11
11
4
</code></pre></div></div>
<p>while循环每次判断用的是外层x的值，进入代码块后，x被重新定义并初始化，代码块里面使用的是暂时的x，每次循环退出时x会被销毁，因此也就有了上面的输出。<strong>写程序千万不要写这种代码！！</strong></p>

<p>==自动变量不会被自动初始化，必须得显式初始化！但是全局变量会存在默认初始化！==</p>
<h2 id="寄存器变量">寄存器变量</h2>
<p>变量一般存储在计算机的内存中，可以通过关键字<code class="highlighter-rouge">register</code>来显式得申请将变量存储在CPU寄存器中或者存储在速度最快的可用内存来达到更快的访问和操作速度。但是，显式得声明变量为寄存器变量并不会导致该变量一定是寄存器变量，这需要编译器考虑到寄存器数目或者高速可用内存数量，如果不行，那么该变量就会变为自动变量。<strong>寄存器变量与自动变量有相同的代码块作用域、空链接、自动存储时期，但是无法使用<code class="highlighter-rouge">&amp;</code>操作符获取寄存器变量的地址，即使没有申请成功，该变量为自动变量，也还是无法获取它的地址。</strong>
<code class="highlighter-rouge">register</code>关键字能够申请的类型是有限的，像C primer plus里提到了处理器可能没有足够大的寄存器来容纳<code class="highlighter-rouge">double</code>类型的数据。</p>
<h2 id="具有代码块作用域的静态变量">具有代码块作用域的静态变量</h2>
<p>静态变量并不是指变量不可变，而是指变量的位置固定不动。在代码块内部使用修饰符<code class="highlighter-rouge">static</code>声明变量会产生具有代码块作用域、空链接但静态的变量。
栗子：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">block_static</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"loop %d</span><span class="se">\n</span><span class="s">:"</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
        <span class="n">block_static</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">block_static</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">test</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"test = %d, foo = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">test</span><span class="o">++</span><span class="p">,</span><span class="n">foo</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>输出结果：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>loop 0
:test = 10, foo = 100
loop 1
:test = 10, foo = 101
loop 2
:test = 10, foo = 102
loop 3
:test = 10, foo = 103
</code></pre></div></div>
<p>静态变量<code class="highlighter-rouge">foo</code>的内存位置固定不变，每次<code class="highlighter-rouge">block_static</code>函数执行时都会访问它的值，它每次增加的值并没有丢失，<code class="highlighter-rouge">static int foo = 100;</code>这个语句既在<code class="highlighter-rouge">block_static</code>第一次执行时声明了静态变量<code class="highlighter-rouge">foo</code>，之后在<code class="highlighter-rouge">block_static</code>每次执行时告诉这个函数<code class="highlighter-rouge">foo</code>对其是可见的，它知道这个变量的地址，它可以去访问。而<code class="highlighter-rouge">test</code>变量就不同，它是自动变量，每次<code class="highlighter-rouge">blocl_static</code>执行时，<code class="highlighter-rouge">test</code>先被分配内存并初始化，执行结束时内存被回收，丢失这个值，下一次函数执行时已经丢失了对原先<code class="highlighter-rouge">test</code>内存地址访问权，会重新创建<code class="highlighter-rouge">test</code>并分配内存然后销毁，周而复始。
形式参量无能使用<code class="highlighter-rouge">static</code>修饰。</p>
<h2 id="具有外部链接的静态变量">具有外部链接的静态变量</h2>
<p>具有外部链接的静态变量具有文件作用域、外部链接和静态存储时期，也被称为外部变量。
当想要创建一个外部变量时，把变量定义在所有函数之外即可，也可以显式地使用	<code class="highlighter-rouge">extern</code>关键字来声明。<strong>当变量是在别的文件定义的时，必须使用<code class="highlighter-rouge">extern</code>声明变量。</strong></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="n">Global</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">extern</span> <span class="kt">int</span> <span class="n">Global</span><span class="p">;</span><span class="c1">//这一行其实可以省略</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>上面的例子中<code class="highlighter-rouge">main</code>函数要访问Global变量无须声明，这样做只是为了表明<code class="highlighter-rouge">main</code>函数需要用它而已。需要注意的是如果这样写：<code class="highlighter-rouge">extern int Global = 10;</code>是会出错的，因为外部变量不允许在函数内部进行定义。变量的声明与定义是不同的。这里<code class="highlighter-rouge">Global</code>既然是外部变量，就不允许函数内部对其进行修改（具体见<a href="https://stackoverflow.com/questions/17090354/why-does-initializing-of-an-extern-variable-locally-inside-a-function-give-an-er">此处</a>）。另外，如果把<code class="highlighter-rouge">extern</code>去掉会产生一个自动变量<code class="highlighter-rouge">Global</code>将外部变量<code class="highlighter-rouge">Global</code>覆盖掉。
外部变量可以显式地初始化，但是若是没有显式初始化，那么默认会被赋值为0。而且，<strong><em>只可以用常量表达式来对外部变量进行初始化</em></strong>。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">Global</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span><span class="c1">//合法，3+10是一个常量表达式</span>
<span class="kt">size_t</span> <span class="n">z</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="c1">//合法，sizeof是编译时运算符，当其操作数不为变长数组时，返回值为一个常量</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="c1">//不合法，y是一个变量</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">extern</span> <span class="kt">int</span> <span class="n">Global</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="extern关键字"><code class="highlighter-rouge">extern</code>关键字</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">tern</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//外部变量tern定义，初始化</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="k">extern</span> <span class="kt">int</span> <span class="n">tern</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在上面的代码段中<code class="highlighter-rouge">tern</code>有两次声明，第一次是对外部变量的定义声明为变量分配了内存空间，第二处因为有<code class="highlighter-rouge">extern</code>存在，表明是对外部变量<code class="highlighter-rouge">extern</code>的引用，为引用声明，并不涉及内存分配。在C Primer Plus中这样说：<code class="highlighter-rouge">关键字extern表明该声明不是一个定义，因为它指示编译器参考其他地方。</code>
如果这样做：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">int</span> <span class="n">tern</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
<span class="p">}</span>
</code></pre></div></div>
<p>那么编译器会假定<code class="highlighter-rouge">tern</code>是在其他文件中定义的外部变量，而不会引起空间分配。因此，<strong>不要用<code class="highlighter-rouge">extern</code>来进行外部定义，只用它来引用一个已经存在的外部定义</strong>。
一个外部变量只允许一次初始化，必须在外部变量被定义声明的同时进行初始化。
<code class="highlighter-rouge">extern int tern = 1000;</code>不合法，因为此时编译器假定<code class="highlighter-rouge">tern</code>已经存在，这是一个引用声明，不是定义声明。不能对<code class="highlighter-rouge">tern</code>进行二次初始化。</p>

<h2 id="具有内部链接的静态变量">具有内部链接的静态变量</h2>
<p>具有内部链接的静态变量具有静态存储时期、文件作用域以及内部链接。它通过<code class="highlighter-rouge">static</code>关键字在函数外部进行定义。
这种变量不同于外部变量，它只能被同文件中的函数进行访问，在函数中同样可以使用<code class="highlighter-rouge">extern</code>关键字来进行引用声明，但不会改变它的内部链接。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">global_full</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span><span class="c1">//外部链接、文件作用域、静态</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">global_not_full</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span><span class="c1">//内部链接、文件作用域、静态</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">extern</span> <span class="kt">int</span> <span class="n">global_full</span><span class="p">;</span>
    <span class="k">extern</span> <span class="kt">int</span> <span class="n">global_not_full</span><span class="p">;</span><span class="c1">//global_not_full仍是内部链接</span>
    <span class="c1">//这两种其实都多余，main中可以直接访问这两个变量</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="多文件">多文件</h2>
<p>当一个C程序包含多个独立代码文件时，若需要共享外部变量，这时候外部链接、内部链接才显得重要。通过在一个文件中定义外部变量，在其他文件中引用声明这个变量实现共享。除了这个本身的定义声明之外，其他所有生命都必须使用关键字<code class="highlighter-rouge">extern</code>来进行引用，并且只能在定义的时候初始化一次。注意，其他文件要想使用这个变量，必须显示的使用<code class="highlighter-rouge">extern</code>声明，否则该变量不能用于其他文件。</p>

<p>这是我对《C Primer Plus》第十二章<code class="highlighter-rouge">存储类、链接和内存管理</code>所写的一部分笔记，未完待续。</p>

</article>
<div id="info-bottom">
<hr>
<p>标签: <block class="tag"><a href="/archive/#c">c</a></block><block class="tag"><a href="/archive/#C Primer Plus">C Primer Plus</a></block></p>
<p><b>留言</b>请用 <a href="https://github.com/foreverlms/foreverlms.github.io/issues"> Github Issues </a></p>
<p><b>聊天</b>请在 <a href="https://gitter.im/foreverlms/community" target="_blank">gitter.im/foreverlms</a> </p>
</div>

</div>
<div class="info-bottom"><div class="info-bottom-text">
License <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a> | Subscribe <a href="/feed.xml">RSS</a> | Email <a href="mailto:codechaser@163.com">codechaser囧163.com</a> | 博客模板 <a href="https://fzheng.me/" target="_blank">无求备斋笔记</a>
</div></div> 
</div>
</body>
<script src="https://use.typekit.net/hvv6ahj.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>
</html>