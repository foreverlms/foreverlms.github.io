<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>C Primer Plus--结构和其他数据类型(1)</title>
	<meta name="description" content="C中结构(Struct)小记-1">
	<meta name="keywords" content="C Primer Plus, c, 寒鸥惊起一双双" />
	<link rel="canonical" href="https://blog.bobliao.xyz/%E7%AC%94%E8%AE%B0/2018/05/16/c-struct-1.html">
	<link rel="alternate" type="application/rss+xml" title="寒鸥惊起一双双" href="https://blog.bobliao.xyz/feed.xml" />
   	<link rel="stylesheet" type="text/css" href="/css/index.css">
</head>

<body>
<div class="body-wrapper">
<div class="nav-header">
<a href="/">寒鸥惊起一双双</a> | <a href="https://github.com/foreverlms" target="_blank">Github</a> |<a href="/about"> 关于我 </a></div>
<div class="main-body">
<header>
<h2>C Primer Plus--结构和其他数据类型(1)</h2>
<p><i>2018-05-16</i></p>
</header>
<article>
<p>C中结构(Struct)小记-1
<!--more--></p>

<h2 id="结构变量-structure-variable">结构变量 structure variable</h2>
<p>C中struct是用来将多种数据类型组合到一起包装成一种新的类型。创建一个<code class="highlighter-rouge">struct</code>数据类型需要：</p>
<ul>
  <li>建立结构的格式或布局</li>
  <li>声明遵循该布局的变量</li>
  <li>获取对一个结构变量的各个成员（member）或者字段（field）的访问</li>
</ul>

<h3 id="建立结构声明">建立结构声明</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">book</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">title</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">author</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">price</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>这样的声明是解释了一个<strong>标记</strong>（可以理解为别名）为<code class="highlighter-rouge">book</code>的<code class="highlighter-rouge">struct</code>类型所包含的数据类型：一个字符串数组-书名，一个字符串数组-作者，一个int-价格，就像一个模板一样。这样的声明只是声明了这样的一个数据对象，并没有实际非配存储空间。当使用这个数据类型时，才会分配空间：
<code class="highlighter-rouge">struct book my_book;</code>
这里就定义了一个<code class="highlighter-rouge">book</code>类型的<code class="highlighter-rouge">struct</code>对象，需要注意的是它里面的数据是没有进行默认初始化的。</p>
<h3 id="定义结构声明">定义结构声明</h3>
<p><code class="highlighter-rouge">struct book my_book;</code>这个语句会使得编译器分配空间来容纳两个数组一个int。还可以这样定义：
<strong>**</strong><strong>**</strong><strong>**</strong>
<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>*****
<code class="highlighter-rouge">struct</code>初始化类似于数组的初始化：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">book</span> <span class="n">mybook</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"爱你就像爱生命"</span><span class="p">,</span>
    <span class="s">"王小波"</span><span class="p">,</span>
    <span class="mi">29</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>还可以指定初始化项目：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">book</span> <span class="n">book1</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">author</span> <span class="o">=</span> <span class="s">"王小波"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="s">"爱你就像爱生命"</span><span class="p">,</span>
        <span class="p">.</span><span class="n">price</span> <span class="o">=</span> <span class="mi">29</span>
<span class="p">};</span>
</code></pre></div></div>
<p>这样初始化不需要保持顺序，而且可以只初始化若干个字段。类似于数组的指定元素初始化，会出现值的覆盖情况：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">book</span> <span class="n">book1</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">price</span> <span class="o">=</span> <span class="mi">29</span><span class="p">,</span>
    <span class="p">.</span><span class="n">author</span> <span class="o">=</span> <span class="s">"王小波"</span><span class="p">,</span>
    <span class="mi">35</span>
<span class="p">};</span>
</code></pre></div></div>
<p>此时书的价格变为35。
<code class="highlighter-rouge">struct</code>结构的元素访问可以用点运算符：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">book</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">title</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">author</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">price</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="n">book</span> <span class="n">mybook</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">"爱你就像爱生命"</span><span class="p">,</span>
            <span class="s">"王小波"</span><span class="p">,</span>
            <span class="mi">29</span><span class="p">.</span>
    <span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span><span class="n">mybook</span><span class="p">.</span><span class="n">title</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="结构数组">结构数组</h2>
<p>声明结构数组：
<code class="highlighter-rouge">struct book books[20]</code>声明了一个可以容纳20本书的数组<code class="highlighter-rouge">books</code>。</p>
<h2 id="嵌套结构">嵌套结构</h2>
<p>允许一个结构的组成元素里面包含另一种结构。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">publishing_house</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">location</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">book</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">publishing_house</span> <span class="n">publishingHouse</span><span class="p">;</span><span class="c1">//book这个类型包含出版社信息结构</span>
    <span class="kt">char</span> <span class="n">title</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">author</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">price</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="n">book</span> <span class="n">mybook</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">{</span><span class="s">"上海文艺出版社"</span><span class="p">,</span>
             <span class="s">"上海"</span><span class="p">},</span>
            <span class="s">"爱你就像爱生命"</span><span class="p">,</span>
            <span class="s">"王小波"</span><span class="p">,</span>
            <span class="mi">29</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="结构指针">结构指针</h2>
<p>声明一个指向结构的指针与普通指针声明方式差不多：
<code class="highlighter-rouge">struct book * ptobook;</code>
但是和数组不同之处在于结构的名字并不是该结构的地址，对<code class="highlighter-rouge">ptobook</code>进行赋值时应该使用<code class="highlighter-rouge">&amp;</code>运算符进行取地址操作：
<code class="highlighter-rouge">ptobook = &amp; my_book;</code></p>
<h3 id="使用指针访问结构成员">使用指针访问结构成员</h3>
<p>两种方法：</p>
<ul>
  <li><code class="highlighter-rouge">-&gt;</code>运算符
<code class="highlighter-rouge">ptobook-&gt;author</code>返回的是<code class="highlighter-rouge">ptobook</code>指向的book结构的<code class="highlighter-rouge">author</code>字段值，是个字符串数组。</li>
  <li><code class="highlighter-rouge">*</code>运算符与<code class="highlighter-rouge">.</code>运算符结合
<code class="highlighter-rouge">(*ptobook).author</code>也是如此。</li>
</ul>

<h2 id="结构用于传参">结构用于传参</h2>
<p>结构用于传参可以有三种方式：</p>
<ul>
  <li>传递结构成员给函数</li>
  <li>传递结构指针给函数</li>
  <li>传递结构本身给函数
<strong>需要注意的是不同于传递结构指针的方式中函数会操作原有结构，向函数传递结构本身会产生一个原有结构的拷贝，这个拷贝是一个自动变量。</strong></li>
</ul>

<p>不同于数组无法互相赋值：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">struct</span> <span class="n">book</span> <span class="n">mybook</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">{</span><span class="s">"上海文艺出版社"</span><span class="p">,</span>
             <span class="s">"上海"</span><span class="p">},</span>
            <span class="s">"爱你就像爱生命"</span><span class="p">,</span>
            <span class="s">"Bob"</span><span class="p">,</span>
            <span class="mi">29</span>
    <span class="p">};</span>
<span class="c1">//    int array1[2] = {1,2};</span>
<span class="c1">//    int array2[2];</span>
<span class="c1">//    array2 = array1;//报错:Array type 'int [2]' is not assignable array2是常量，=左边应该是变量。数组无法整体赋值。</span>

    <span class="k">struct</span> <span class="n">book</span> <span class="n">the_same_book</span><span class="p">;</span>
    <span class="n">the_same_book</span> <span class="o">=</span> <span class="n">mybook</span><span class="p">;</span><span class="c1">//合法</span>

    <span class="n">mybook</span><span class="p">.</span><span class="n">price</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="n">mybook</span><span class="p">.</span><span class="n">author</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"my_book: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">mybook</span><span class="p">.</span><span class="n">author</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"the same book: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">the_same_book</span><span class="p">.</span><span class="n">author</span><span class="p">);</span>
</code></pre></div></div>
<p>发现这样操作<code class="highlighter-rouge">my_book</code>里面的所有成员都被重新拷贝了另一份，即使是数组也被完整拷贝了。</p>

<p>结构也可以作为函数的返回值。</p>

<h3 id="在结构中使用指针的危害">在结构中使用指针的危害</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">name</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">firs</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">last</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pname</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">second</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p><strong>在上面的代码中，两个struct结构中用了数组和指针两种方式来表明两个字符串变量。但是在指针方式中，指针没有初始化，那么创建的<code class="highlighter-rouge">pname</code>对象中的字符串存储位置也就不确定，很可能会造成程序的崩溃。而使用数组方式就不用担心，因为数组会被分配专门的空间，不会造成修改其他正在被占用的内存里的数据。</strong></p>

<h2 id="联合union数据结构">联合(Union)数据结构</h2>
<p><code class="highlighter-rouge">union</code>这种数据结构很有意思，它允许你像声明<code class="highlighter-rouge">struct</code>那样创建一个模板，里面可以有各种数据类型。但是不同的是，它在某个时刻只能存储一个模板里的数据类型，也就是说，<code class="highlighter-rouge">union</code>是用来存放不确定数据类型的数据。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">union</span> <span class="n">union_</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">money</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">price</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>这样的一个<code class="highlighter-rouge">union_</code>某个时刻只能存储<code class="highlighter-rouge">int</code>、<code class="highlighter-rouge">double</code>、<code class="highlighter-rouge">char</code>三种类型其中的一个数据。使用示例：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">union</span> <span class="n">union_</span> <span class="n">foo</span><span class="p">;</span>
<span class="n">foo</span><span class="p">.</span><span class="n">money</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span><span class="c1">//将1000存储在foo中</span>
<span class="n">foo</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span><span class="c1">//清除1000，将'A'存储在foo中</span>
<span class="n">foo</span><span class="p">.</span><span class="n">price</span> <span class="o">=</span> <span class="mi">100</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span><span class="c1">//清除'A'，将100.5存储在foo中</span>
</code></pre></div></div>
<p>编译器给<code class="highlighter-rouge">foo</code>分配的空间按<code class="highlighter-rouge">int</code>、<code class="highlighter-rouge">double</code>、<code class="highlighter-rouge">char</code>三种数据类型中所需的最大字节数来分配以保证可以满足可能出现的三种存储情况。<code class="highlighter-rouge">union</code>同样支持互相赋值及<code class="highlighter-rouge">-&gt;</code>运算符。<code class="highlighter-rouge">union</code>可以声明<code class="highlighter-rouge">struct</code>是它可能需要存储的数据类型。</p>


</article>
<div id="info-bottom">
<hr>
<p>标签: <block class="tag"><a href="/archive/#C Primer Plus">C Primer Plus</a></block><block class="tag"><a href="/archive/#c">c</a></block></p>
<p><b>留言</b>请用 <a href="https://github.com/foreverlms/foreverlms.github.io/issues"> Github Issues </a></p>
<p><b>聊天</b>请在 <a href="https://gitter.im/foreverlms/community" target="_blank">gitter.im/foreverlms</a> </p>
</div>

</div>
<div class="info-bottom"><div class="info-bottom-text">
License <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a> | Subscribe <a href="/feed.xml">RSS</a> | Email <a href="mailto:codechaser@163.com">codechaser囧163.com</a> | 博客模板 <a href="https://fzheng.me/" target="_blank">无求备斋笔记</a>
</div></div> 
</div>
</body>
<script src="https://use.typekit.net/hvv6ahj.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>
</html>